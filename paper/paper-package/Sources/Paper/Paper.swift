// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(PaperFFI)
import PaperFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_paper_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_paper_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




public protocol AuthenticatorProtocol : AnyObject {
    
    func verifyCredentials() async throws  -> ValidationStatus
    
}

open class Authenticator:
    AuthenticatorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paper_fn_clone_authenticator(self.pointer, $0) }
    }
public convenience init(configuration: Configuration) {
    let pointer =
        try! rustCall() {
    uniffi_paper_fn_constructor_authenticator_new(
        FfiConverterTypeConfiguration.lower(configuration),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paper_fn_free_authenticator(pointer, $0) }
    }

    

    
open func verifyCredentials()async throws  -> ValidationStatus {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_paper_fn_method_authenticator_verify_credentials(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_paper_rust_future_poll_rust_buffer,
            completeFunc: ffi_paper_rust_future_complete_rust_buffer,
            freeFunc: ffi_paper_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeValidationStatus.lift,
            errorHandler: FfiConverterTypePaperError.lift
        )
}
    

}

public struct FfiConverterTypeAuthenticator: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Authenticator

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Authenticator {
        return Authenticator(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Authenticator) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Authenticator {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Authenticator, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeAuthenticator_lift(_ pointer: UnsafeMutableRawPointer) throws -> Authenticator {
    return try FfiConverterTypeAuthenticator.lift(pointer)
}

public func FfiConverterTypeAuthenticator_lower(_ value: Authenticator) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAuthenticator.lower(value)
}




public protocol HamburgPublicSearchDetailScraperProtocol : AnyObject {
    
}

open class HamburgPublicSearchDetailScraper:
    HamburgPublicSearchDetailScraperProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paper_fn_clone_hamburgpublicsearchdetailscraper(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paper_fn_free_hamburgpublicsearchdetailscraper(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeHamburgPublicSearchDetailScraper: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HamburgPublicSearchDetailScraper

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HamburgPublicSearchDetailScraper {
        return HamburgPublicSearchDetailScraper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HamburgPublicSearchDetailScraper) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HamburgPublicSearchDetailScraper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HamburgPublicSearchDetailScraper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeHamburgPublicSearchDetailScraper_lift(_ pointer: UnsafeMutableRawPointer) throws -> HamburgPublicSearchDetailScraper {
    return try FfiConverterTypeHamburgPublicSearchDetailScraper.lift(pointer)
}

public func FfiConverterTypeHamburgPublicSearchDetailScraper_lower(_ value: HamburgPublicSearchDetailScraper) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHamburgPublicSearchDetailScraper.lower(value)
}




public protocol LibraryScraperProtocol : AnyObject {
    
    func fetchAccount() async throws  -> Account
    
}

open class LibraryScraper:
    LibraryScraperProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paper_fn_clone_libraryscraper(self.pointer, $0) }
    }
public convenience init(configuration: Configuration) {
    let pointer =
        try! rustCall() {
    uniffi_paper_fn_constructor_libraryscraper_new(
        FfiConverterTypeConfiguration.lower(configuration),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paper_fn_free_libraryscraper(pointer, $0) }
    }

    

    
open func fetchAccount()async throws  -> Account {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_paper_fn_method_libraryscraper_fetch_account(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_paper_rust_future_poll_rust_buffer,
            completeFunc: ffi_paper_rust_future_complete_rust_buffer,
            freeFunc: ffi_paper_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAccount.lift,
            errorHandler: FfiConverterTypePaperError.lift
        )
}
    

}

public struct FfiConverterTypeLibraryScraper: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LibraryScraper

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LibraryScraper {
        return LibraryScraper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LibraryScraper) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LibraryScraper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LibraryScraper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeLibraryScraper_lift(_ pointer: UnsafeMutableRawPointer) throws -> LibraryScraper {
    return try FfiConverterTypeLibraryScraper.lift(pointer)
}

public func FfiConverterTypeLibraryScraper_lower(_ value: LibraryScraper) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLibraryScraper.lower(value)
}




public protocol RenewalServiceProtocol : AnyObject {
    
    func opc4v213vzg6Renew(renewalToken: String, configuration: Configuration) async throws  -> Loan
    
    func publicHamburgRenew(itemNumber: String, configuration: Configuration) async throws  -> Loan
    
    func renew(itemNumber: String, renewalToken: String?, configuration: Configuration) async throws  -> Loan
    
}

open class RenewalService:
    RenewalServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paper_fn_clone_renewalservice(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_paper_fn_constructor_renewalservice_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paper_fn_free_renewalservice(pointer, $0) }
    }

    

    
open func opc4v213vzg6Renew(renewalToken: String, configuration: Configuration)async throws  -> Loan {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_paper_fn_method_renewalservice_opc4v2_13vzg6_renew(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(renewalToken),FfiConverterTypeConfiguration.lower(configuration)
                )
            },
            pollFunc: ffi_paper_rust_future_poll_rust_buffer,
            completeFunc: ffi_paper_rust_future_complete_rust_buffer,
            freeFunc: ffi_paper_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLoan.lift,
            errorHandler: FfiConverterTypePaperError.lift
        )
}
    
open func publicHamburgRenew(itemNumber: String, configuration: Configuration)async throws  -> Loan {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_paper_fn_method_renewalservice_public_hamburg_renew(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(itemNumber),FfiConverterTypeConfiguration.lower(configuration)
                )
            },
            pollFunc: ffi_paper_rust_future_poll_rust_buffer,
            completeFunc: ffi_paper_rust_future_complete_rust_buffer,
            freeFunc: ffi_paper_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLoan.lift,
            errorHandler: FfiConverterTypePaperError.lift
        )
}
    
open func renew(itemNumber: String, renewalToken: String?, configuration: Configuration)async throws  -> Loan {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_paper_fn_method_renewalservice_renew(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(itemNumber),FfiConverterOptionString.lower(renewalToken),FfiConverterTypeConfiguration.lower(configuration)
                )
            },
            pollFunc: ffi_paper_rust_future_poll_rust_buffer,
            completeFunc: ffi_paper_rust_future_complete_rust_buffer,
            freeFunc: ffi_paper_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLoan.lift,
            errorHandler: FfiConverterTypePaperError.lift
        )
}
    

}

public struct FfiConverterTypeRenewalService: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RenewalService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RenewalService {
        return RenewalService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RenewalService) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RenewalService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RenewalService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRenewalService_lift(_ pointer: UnsafeMutableRawPointer) throws -> RenewalService {
    return try FfiConverterTypeRenewalService.lift(pointer)
}

public func FfiConverterTypeRenewalService_lower(_ value: RenewalService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRenewalService.lower(value)
}




public protocol SearchDetailScraperProtocol : AnyObject {
    
    func detailsForUrl(url: String) async throws  -> SearchResultDetail
    
    func status(availabilities: [Availability])  -> AvailabilityStatus
    
}

open class SearchDetailScraper:
    SearchDetailScraperProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paper_fn_clone_searchdetailscraper(self.pointer, $0) }
    }
public convenience init(configuration: ApiConfiguration) {
    let pointer =
        try! rustCall() {
    uniffi_paper_fn_constructor_searchdetailscraper_new(
        FfiConverterTypeAPIConfiguration.lower(configuration),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paper_fn_free_searchdetailscraper(pointer, $0) }
    }

    

    
open func detailsForUrl(url: String)async throws  -> SearchResultDetail {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_paper_fn_method_searchdetailscraper_details_for_url(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_paper_rust_future_poll_rust_buffer,
            completeFunc: ffi_paper_rust_future_complete_rust_buffer,
            freeFunc: ffi_paper_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSearchResultDetail.lift,
            errorHandler: FfiConverterTypePaperError.lift
        )
}
    
open func status(availabilities: [Availability]) -> AvailabilityStatus {
    return try!  FfiConverterTypeAvailabilityStatus.lift(try! rustCall() {
    uniffi_paper_fn_method_searchdetailscraper_status(self.uniffiClonePointer(),
        FfiConverterSequenceTypeAvailability.lower(availabilities),$0
    )
})
}
    

}

public struct FfiConverterTypeSearchDetailScraper: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SearchDetailScraper

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SearchDetailScraper {
        return SearchDetailScraper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SearchDetailScraper) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchDetailScraper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SearchDetailScraper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSearchDetailScraper_lift(_ pointer: UnsafeMutableRawPointer) throws -> SearchDetailScraper {
    return try FfiConverterTypeSearchDetailScraper.lift(pointer)
}

public func FfiConverterTypeSearchDetailScraper_lower(_ value: SearchDetailScraper) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSearchDetailScraper.lower(value)
}




public protocol SearchScraperProtocol : AnyObject {
    
    func search(text: String, nextPageUrl: String?) async throws  -> SearchResultList
    
}

open class SearchScraper:
    SearchScraperProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paper_fn_clone_searchscraper(self.pointer, $0) }
    }
public convenience init(configuration: ApiConfiguration) {
    let pointer =
        try! rustCall() {
    uniffi_paper_fn_constructor_searchscraper_new(
        FfiConverterTypeAPIConfiguration.lower(configuration),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paper_fn_free_searchscraper(pointer, $0) }
    }

    

    
open func search(text: String, nextPageUrl: String?)async throws  -> SearchResultList {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_paper_fn_method_searchscraper_search(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(text),FfiConverterOptionString.lower(nextPageUrl)
                )
            },
            pollFunc: ffi_paper_rust_future_poll_rust_buffer,
            completeFunc: ffi_paper_rust_future_complete_rust_buffer,
            freeFunc: ffi_paper_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSearchResultList.lift,
            errorHandler: FfiConverterTypePaperError.lift
        )
}
    

}

public struct FfiConverterTypeSearchScraper: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SearchScraper

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SearchScraper {
        return SearchScraper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SearchScraper) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchScraper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SearchScraper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSearchScraper_lift(_ pointer: UnsafeMutableRawPointer) throws -> SearchScraper {
    return try FfiConverterTypeSearchScraper.lift(pointer)
}

public func FfiConverterTypeSearchScraper_lower(_ value: SearchScraper) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSearchScraper.lower(value)
}


public struct ApiConfiguration {
    public var api: Api
    public var baseUrl: String
    public var catalogUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(api: Api, baseUrl: String, catalogUrl: String) {
        self.api = api
        self.baseUrl = baseUrl
        self.catalogUrl = catalogUrl
    }
}



extension ApiConfiguration: Equatable, Hashable {
    public static func ==(lhs: ApiConfiguration, rhs: ApiConfiguration) -> Bool {
        if lhs.api != rhs.api {
            return false
        }
        if lhs.baseUrl != rhs.baseUrl {
            return false
        }
        if lhs.catalogUrl != rhs.catalogUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(api)
        hasher.combine(baseUrl)
        hasher.combine(catalogUrl)
    }
}


public struct FfiConverterTypeAPIConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApiConfiguration {
        return
            try ApiConfiguration(
                api: FfiConverterTypeAPI.read(from: &buf), 
                baseUrl: FfiConverterString.read(from: &buf), 
                catalogUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApiConfiguration, into buf: inout [UInt8]) {
        FfiConverterTypeAPI.write(value.api, into: &buf)
        FfiConverterString.write(value.baseUrl, into: &buf)
        FfiConverterString.write(value.catalogUrl, into: &buf)
    }
}


public func FfiConverterTypeAPIConfiguration_lift(_ buf: RustBuffer) throws -> ApiConfiguration {
    return try FfiConverterTypeAPIConfiguration.lift(buf)
}

public func FfiConverterTypeAPIConfiguration_lower(_ value: ApiConfiguration) -> RustBuffer {
    return FfiConverterTypeAPIConfiguration.lower(value)
}


public struct Account {
    public var accountId: String
    public var name: String
    public var address: String
    public var phone: String
    public var email: String
    public var chargeInfo: [String: String]
    public var loans: Loans
    public var balance: Balance?
    public var notifications: [Notification]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accountId: String, name: String, address: String, phone: String, email: String, chargeInfo: [String: String], loans: Loans, balance: Balance?, notifications: [Notification]) {
        self.accountId = accountId
        self.name = name
        self.address = address
        self.phone = phone
        self.email = email
        self.chargeInfo = chargeInfo
        self.loans = loans
        self.balance = balance
        self.notifications = notifications
    }
}



extension Account: Equatable, Hashable {
    public static func ==(lhs: Account, rhs: Account) -> Bool {
        if lhs.accountId != rhs.accountId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.phone != rhs.phone {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.chargeInfo != rhs.chargeInfo {
            return false
        }
        if lhs.loans != rhs.loans {
            return false
        }
        if lhs.balance != rhs.balance {
            return false
        }
        if lhs.notifications != rhs.notifications {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountId)
        hasher.combine(name)
        hasher.combine(address)
        hasher.combine(phone)
        hasher.combine(email)
        hasher.combine(chargeInfo)
        hasher.combine(loans)
        hasher.combine(balance)
        hasher.combine(notifications)
    }
}


public struct FfiConverterTypeAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Account {
        return
            try Account(
                accountId: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                address: FfiConverterString.read(from: &buf), 
                phone: FfiConverterString.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                chargeInfo: FfiConverterDictionaryStringString.read(from: &buf), 
                loans: FfiConverterTypeLoans.read(from: &buf), 
                balance: FfiConverterOptionTypeBalance.read(from: &buf), 
                notifications: FfiConverterSequenceTypeNotification.read(from: &buf)
        )
    }

    public static func write(_ value: Account, into buf: inout [UInt8]) {
        FfiConverterString.write(value.accountId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterString.write(value.phone, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterDictionaryStringString.write(value.chargeInfo, into: &buf)
        FfiConverterTypeLoans.write(value.loans, into: &buf)
        FfiConverterOptionTypeBalance.write(value.balance, into: &buf)
        FfiConverterSequenceTypeNotification.write(value.notifications, into: &buf)
    }
}


public func FfiConverterTypeAccount_lift(_ buf: RustBuffer) throws -> Account {
    return try FfiConverterTypeAccount.lift(buf)
}

public func FfiConverterTypeAccount_lower(_ value: Account) -> RustBuffer {
    return FfiConverterTypeAccount.lower(value)
}


public struct AccountInfo {
    public var readableFullName: String?
    public var categoryName: String?
    public var accountBalance: String?
    public var badgeReplacementCharge: String?
    public var creditBalance: String?
    public var mandatoryCreditBalance: String?
    public var pseudoForename: String?
    public var creationDate: String?
    public var fullName: String?
    public var birthDate: String?
    public var branchName: String?
    public var amount: String?
    public var change: String?
    public var start: String?
    public var expiry: String?
    public var expiryMonth: String?
    public var expiryYear: String?
    public var postcode: String?
    public var surname: String?
    public var forename: String?
    public var emailAddress: String?
    public var addressLine1: String?
    public var addressLine2: String?
    public var acronym: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(readableFullName: String?, categoryName: String?, accountBalance: String?, badgeReplacementCharge: String?, creditBalance: String?, mandatoryCreditBalance: String?, pseudoForename: String?, creationDate: String?, fullName: String?, birthDate: String?, branchName: String?, amount: String?, change: String?, start: String?, expiry: String?, expiryMonth: String?, expiryYear: String?, postcode: String?, surname: String?, forename: String?, emailAddress: String?, addressLine1: String?, addressLine2: String?, acronym: String?) {
        self.readableFullName = readableFullName
        self.categoryName = categoryName
        self.accountBalance = accountBalance
        self.badgeReplacementCharge = badgeReplacementCharge
        self.creditBalance = creditBalance
        self.mandatoryCreditBalance = mandatoryCreditBalance
        self.pseudoForename = pseudoForename
        self.creationDate = creationDate
        self.fullName = fullName
        self.birthDate = birthDate
        self.branchName = branchName
        self.amount = amount
        self.change = change
        self.start = start
        self.expiry = expiry
        self.expiryMonth = expiryMonth
        self.expiryYear = expiryYear
        self.postcode = postcode
        self.surname = surname
        self.forename = forename
        self.emailAddress = emailAddress
        self.addressLine1 = addressLine1
        self.addressLine2 = addressLine2
        self.acronym = acronym
    }
}



extension AccountInfo: Equatable, Hashable {
    public static func ==(lhs: AccountInfo, rhs: AccountInfo) -> Bool {
        if lhs.readableFullName != rhs.readableFullName {
            return false
        }
        if lhs.categoryName != rhs.categoryName {
            return false
        }
        if lhs.accountBalance != rhs.accountBalance {
            return false
        }
        if lhs.badgeReplacementCharge != rhs.badgeReplacementCharge {
            return false
        }
        if lhs.creditBalance != rhs.creditBalance {
            return false
        }
        if lhs.mandatoryCreditBalance != rhs.mandatoryCreditBalance {
            return false
        }
        if lhs.pseudoForename != rhs.pseudoForename {
            return false
        }
        if lhs.creationDate != rhs.creationDate {
            return false
        }
        if lhs.fullName != rhs.fullName {
            return false
        }
        if lhs.birthDate != rhs.birthDate {
            return false
        }
        if lhs.branchName != rhs.branchName {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.change != rhs.change {
            return false
        }
        if lhs.start != rhs.start {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        if lhs.expiryMonth != rhs.expiryMonth {
            return false
        }
        if lhs.expiryYear != rhs.expiryYear {
            return false
        }
        if lhs.postcode != rhs.postcode {
            return false
        }
        if lhs.surname != rhs.surname {
            return false
        }
        if lhs.forename != rhs.forename {
            return false
        }
        if lhs.emailAddress != rhs.emailAddress {
            return false
        }
        if lhs.addressLine1 != rhs.addressLine1 {
            return false
        }
        if lhs.addressLine2 != rhs.addressLine2 {
            return false
        }
        if lhs.acronym != rhs.acronym {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(readableFullName)
        hasher.combine(categoryName)
        hasher.combine(accountBalance)
        hasher.combine(badgeReplacementCharge)
        hasher.combine(creditBalance)
        hasher.combine(mandatoryCreditBalance)
        hasher.combine(pseudoForename)
        hasher.combine(creationDate)
        hasher.combine(fullName)
        hasher.combine(birthDate)
        hasher.combine(branchName)
        hasher.combine(amount)
        hasher.combine(change)
        hasher.combine(start)
        hasher.combine(expiry)
        hasher.combine(expiryMonth)
        hasher.combine(expiryYear)
        hasher.combine(postcode)
        hasher.combine(surname)
        hasher.combine(forename)
        hasher.combine(emailAddress)
        hasher.combine(addressLine1)
        hasher.combine(addressLine2)
        hasher.combine(acronym)
    }
}


public struct FfiConverterTypeAccountInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountInfo {
        return
            try AccountInfo(
                readableFullName: FfiConverterOptionString.read(from: &buf), 
                categoryName: FfiConverterOptionString.read(from: &buf), 
                accountBalance: FfiConverterOptionString.read(from: &buf), 
                badgeReplacementCharge: FfiConverterOptionString.read(from: &buf), 
                creditBalance: FfiConverterOptionString.read(from: &buf), 
                mandatoryCreditBalance: FfiConverterOptionString.read(from: &buf), 
                pseudoForename: FfiConverterOptionString.read(from: &buf), 
                creationDate: FfiConverterOptionString.read(from: &buf), 
                fullName: FfiConverterOptionString.read(from: &buf), 
                birthDate: FfiConverterOptionString.read(from: &buf), 
                branchName: FfiConverterOptionString.read(from: &buf), 
                amount: FfiConverterOptionString.read(from: &buf), 
                change: FfiConverterOptionString.read(from: &buf), 
                start: FfiConverterOptionString.read(from: &buf), 
                expiry: FfiConverterOptionString.read(from: &buf), 
                expiryMonth: FfiConverterOptionString.read(from: &buf), 
                expiryYear: FfiConverterOptionString.read(from: &buf), 
                postcode: FfiConverterOptionString.read(from: &buf), 
                surname: FfiConverterOptionString.read(from: &buf), 
                forename: FfiConverterOptionString.read(from: &buf), 
                emailAddress: FfiConverterOptionString.read(from: &buf), 
                addressLine1: FfiConverterOptionString.read(from: &buf), 
                addressLine2: FfiConverterOptionString.read(from: &buf), 
                acronym: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AccountInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.readableFullName, into: &buf)
        FfiConverterOptionString.write(value.categoryName, into: &buf)
        FfiConverterOptionString.write(value.accountBalance, into: &buf)
        FfiConverterOptionString.write(value.badgeReplacementCharge, into: &buf)
        FfiConverterOptionString.write(value.creditBalance, into: &buf)
        FfiConverterOptionString.write(value.mandatoryCreditBalance, into: &buf)
        FfiConverterOptionString.write(value.pseudoForename, into: &buf)
        FfiConverterOptionString.write(value.creationDate, into: &buf)
        FfiConverterOptionString.write(value.fullName, into: &buf)
        FfiConverterOptionString.write(value.birthDate, into: &buf)
        FfiConverterOptionString.write(value.branchName, into: &buf)
        FfiConverterOptionString.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.change, into: &buf)
        FfiConverterOptionString.write(value.start, into: &buf)
        FfiConverterOptionString.write(value.expiry, into: &buf)
        FfiConverterOptionString.write(value.expiryMonth, into: &buf)
        FfiConverterOptionString.write(value.expiryYear, into: &buf)
        FfiConverterOptionString.write(value.postcode, into: &buf)
        FfiConverterOptionString.write(value.surname, into: &buf)
        FfiConverterOptionString.write(value.forename, into: &buf)
        FfiConverterOptionString.write(value.emailAddress, into: &buf)
        FfiConverterOptionString.write(value.addressLine1, into: &buf)
        FfiConverterOptionString.write(value.addressLine2, into: &buf)
        FfiConverterOptionString.write(value.acronym, into: &buf)
    }
}


public func FfiConverterTypeAccountInfo_lift(_ buf: RustBuffer) throws -> AccountInfo {
    return try FfiConverterTypeAccountInfo.lift(buf)
}

public func FfiConverterTypeAccountInfo_lower(_ value: AccountInfo) -> RustBuffer {
    return FfiConverterTypeAccountInfo.lower(value)
}


public struct Balance {
    public var total: String
    public var charges: [Charge]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(total: String, charges: [Charge]) {
        self.total = total
        self.charges = charges
    }
}



extension Balance: Equatable, Hashable {
    public static func ==(lhs: Balance, rhs: Balance) -> Bool {
        if lhs.total != rhs.total {
            return false
        }
        if lhs.charges != rhs.charges {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(total)
        hasher.combine(charges)
    }
}


public struct FfiConverterTypeBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balance {
        return
            try Balance(
                total: FfiConverterString.read(from: &buf), 
                charges: FfiConverterSequenceTypeCharge.read(from: &buf)
        )
    }

    public static func write(_ value: Balance, into buf: inout [UInt8]) {
        FfiConverterString.write(value.total, into: &buf)
        FfiConverterSequenceTypeCharge.write(value.charges, into: &buf)
    }
}


public func FfiConverterTypeBalance_lift(_ buf: RustBuffer) throws -> Balance {
    return try FfiConverterTypeBalance.lift(buf)
}

public func FfiConverterTypeBalance_lower(_ value: Balance) -> RustBuffer {
    return FfiConverterTypeBalance.lower(value)
}


public struct Charge {
    public var timestamp: Int64
    public var amountOwed: Double
    public var amountPayed: Double
    public var reason: String
    public var item: String
    public var source: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(timestamp: Int64, amountOwed: Double, amountPayed: Double, reason: String, item: String, source: String) {
        self.timestamp = timestamp
        self.amountOwed = amountOwed
        self.amountPayed = amountPayed
        self.reason = reason
        self.item = item
        self.source = source
    }
}



extension Charge: Equatable, Hashable {
    public static func ==(lhs: Charge, rhs: Charge) -> Bool {
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.amountOwed != rhs.amountOwed {
            return false
        }
        if lhs.amountPayed != rhs.amountPayed {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.item != rhs.item {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(timestamp)
        hasher.combine(amountOwed)
        hasher.combine(amountPayed)
        hasher.combine(reason)
        hasher.combine(item)
        hasher.combine(source)
    }
}


public struct FfiConverterTypeCharge: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Charge {
        return
            try Charge(
                timestamp: FfiConverterInt64.read(from: &buf), 
                amountOwed: FfiConverterDouble.read(from: &buf), 
                amountPayed: FfiConverterDouble.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf), 
                item: FfiConverterString.read(from: &buf), 
                source: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Charge, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.timestamp, into: &buf)
        FfiConverterDouble.write(value.amountOwed, into: &buf)
        FfiConverterDouble.write(value.amountPayed, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
        FfiConverterString.write(value.item, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
    }
}


public func FfiConverterTypeCharge_lift(_ buf: RustBuffer) throws -> Charge {
    return try FfiConverterTypeCharge.lift(buf)
}

public func FfiConverterTypeCharge_lower(_ value: Charge) -> RustBuffer {
    return FfiConverterTypeCharge.lower(value)
}


public struct Configuration {
    public var username: String?
    public var password: String?
    public var apiConfiguration: ApiConfiguration

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String?, password: String?, apiConfiguration: ApiConfiguration) {
        self.username = username
        self.password = password
        self.apiConfiguration = apiConfiguration
    }
}



extension Configuration: Equatable, Hashable {
    public static func ==(lhs: Configuration, rhs: Configuration) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.apiConfiguration != rhs.apiConfiguration {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(password)
        hasher.combine(apiConfiguration)
    }
}


public struct FfiConverterTypeConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Configuration {
        return
            try Configuration(
                username: FfiConverterOptionString.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf), 
                apiConfiguration: FfiConverterTypeAPIConfiguration.read(from: &buf)
        )
    }

    public static func write(_ value: Configuration, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
        FfiConverterTypeAPIConfiguration.write(value.apiConfiguration, into: &buf)
    }
}


public func FfiConverterTypeConfiguration_lift(_ buf: RustBuffer) throws -> Configuration {
    return try FfiConverterTypeConfiguration.lift(buf)
}

public func FfiConverterTypeConfiguration_lower(_ value: Configuration) -> RustBuffer {
    return FfiConverterTypeConfiguration.lower(value)
}


public struct DataEntry {
    public var label: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(label: String, value: String) {
        self.label = label
        self.value = value
    }
}



extension DataEntry: Equatable, Hashable {
    public static func ==(lhs: DataEntry, rhs: DataEntry) -> Bool {
        if lhs.label != rhs.label {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(label)
        hasher.combine(value)
    }
}


public struct FfiConverterTypeDataEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DataEntry {
        return
            try DataEntry(
                label: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DataEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeDataEntry_lift(_ buf: RustBuffer) throws -> DataEntry {
    return try FfiConverterTypeDataEntry.lift(buf)
}

public func FfiConverterTypeDataEntry_lower(_ value: DataEntry) -> RustBuffer {
    return FfiConverterTypeDataEntry.lower(value)
}


public struct ItemAvailability {
    public var availabilities: [Availability]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(availabilities: [Availability]) {
        self.availabilities = availabilities
    }
}



extension ItemAvailability: Equatable, Hashable {
    public static func ==(lhs: ItemAvailability, rhs: ItemAvailability) -> Bool {
        if lhs.availabilities != rhs.availabilities {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(availabilities)
    }
}


public struct FfiConverterTypeItemAvailability: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ItemAvailability {
        return
            try ItemAvailability(
                availabilities: FfiConverterSequenceTypeAvailability.read(from: &buf)
        )
    }

    public static func write(_ value: ItemAvailability, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAvailability.write(value.availabilities, into: &buf)
    }
}


public func FfiConverterTypeItemAvailability_lift(_ buf: RustBuffer) throws -> ItemAvailability {
    return try FfiConverterTypeItemAvailability.lift(buf)
}

public func FfiConverterTypeItemAvailability_lower(_ value: ItemAvailability) -> RustBuffer {
    return FfiConverterTypeItemAvailability.lower(value)
}


public struct Loan {
    public var title: String
    public var author: String
    public var canRenew: Bool
    public var renewalToken: String?
    public var renewalsCount: UInt8
    public var dateDue: String
    public var borrowedAt: String
    public var itemNumber: String
    public var lockedByPreorder: Bool
    public var details: SearchResultDetail
    public var searchResultDetailUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String, author: String, canRenew: Bool, renewalToken: String?, renewalsCount: UInt8, dateDue: String, borrowedAt: String, itemNumber: String, lockedByPreorder: Bool, details: SearchResultDetail, searchResultDetailUrl: String?) {
        self.title = title
        self.author = author
        self.canRenew = canRenew
        self.renewalToken = renewalToken
        self.renewalsCount = renewalsCount
        self.dateDue = dateDue
        self.borrowedAt = borrowedAt
        self.itemNumber = itemNumber
        self.lockedByPreorder = lockedByPreorder
        self.details = details
        self.searchResultDetailUrl = searchResultDetailUrl
    }
}



extension Loan: Equatable, Hashable {
    public static func ==(lhs: Loan, rhs: Loan) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.canRenew != rhs.canRenew {
            return false
        }
        if lhs.renewalToken != rhs.renewalToken {
            return false
        }
        if lhs.renewalsCount != rhs.renewalsCount {
            return false
        }
        if lhs.dateDue != rhs.dateDue {
            return false
        }
        if lhs.borrowedAt != rhs.borrowedAt {
            return false
        }
        if lhs.itemNumber != rhs.itemNumber {
            return false
        }
        if lhs.lockedByPreorder != rhs.lockedByPreorder {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        if lhs.searchResultDetailUrl != rhs.searchResultDetailUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(author)
        hasher.combine(canRenew)
        hasher.combine(renewalToken)
        hasher.combine(renewalsCount)
        hasher.combine(dateDue)
        hasher.combine(borrowedAt)
        hasher.combine(itemNumber)
        hasher.combine(lockedByPreorder)
        hasher.combine(details)
        hasher.combine(searchResultDetailUrl)
    }
}


public struct FfiConverterTypeLoan: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Loan {
        return
            try Loan(
                title: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                canRenew: FfiConverterBool.read(from: &buf), 
                renewalToken: FfiConverterOptionString.read(from: &buf), 
                renewalsCount: FfiConverterUInt8.read(from: &buf), 
                dateDue: FfiConverterString.read(from: &buf), 
                borrowedAt: FfiConverterString.read(from: &buf), 
                itemNumber: FfiConverterString.read(from: &buf), 
                lockedByPreorder: FfiConverterBool.read(from: &buf), 
                details: FfiConverterTypeSearchResultDetail.read(from: &buf), 
                searchResultDetailUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Loan, into buf: inout [UInt8]) {
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterBool.write(value.canRenew, into: &buf)
        FfiConverterOptionString.write(value.renewalToken, into: &buf)
        FfiConverterUInt8.write(value.renewalsCount, into: &buf)
        FfiConverterString.write(value.dateDue, into: &buf)
        FfiConverterString.write(value.borrowedAt, into: &buf)
        FfiConverterString.write(value.itemNumber, into: &buf)
        FfiConverterBool.write(value.lockedByPreorder, into: &buf)
        FfiConverterTypeSearchResultDetail.write(value.details, into: &buf)
        FfiConverterOptionString.write(value.searchResultDetailUrl, into: &buf)
    }
}


public func FfiConverterTypeLoan_lift(_ buf: RustBuffer) throws -> Loan {
    return try FfiConverterTypeLoan.lift(buf)
}

public func FfiConverterTypeLoan_lower(_ value: Loan) -> RustBuffer {
    return FfiConverterTypeLoan.lower(value)
}


public struct Loans {
    public var loans: [Loan]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(loans: [Loan]) {
        self.loans = loans
    }
}



extension Loans: Equatable, Hashable {
    public static func ==(lhs: Loans, rhs: Loans) -> Bool {
        if lhs.loans != rhs.loans {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(loans)
    }
}


public struct FfiConverterTypeLoans: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Loans {
        return
            try Loans(
                loans: FfiConverterSequenceTypeLoan.read(from: &buf)
        )
    }

    public static func write(_ value: Loans, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeLoan.write(value.loans, into: &buf)
    }
}


public func FfiConverterTypeLoans_lift(_ buf: RustBuffer) throws -> Loans {
    return try FfiConverterTypeLoans.lift(buf)
}

public func FfiConverterTypeLoans_lower(_ value: Loans) -> RustBuffer {
    return FfiConverterTypeLoans.lower(value)
}


public struct Location {
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String) {
        self.name = name
    }
}



extension Location: Equatable, Hashable {
    public static func ==(lhs: Location, rhs: Location) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
    }
}


public struct FfiConverterTypeLocation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Location {
        return
            try Location(
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Location, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeLocation_lift(_ buf: RustBuffer) throws -> Location {
    return try FfiConverterTypeLocation.lift(buf)
}

public func FfiConverterTypeLocation_lower(_ value: Location) -> RustBuffer {
    return FfiConverterTypeLocation.lower(value)
}


public struct Notification {
    public var notificationType: NotificationType
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(notificationType: NotificationType, message: String) {
        self.notificationType = notificationType
        self.message = message
    }
}



extension Notification: Equatable, Hashable {
    public static func ==(lhs: Notification, rhs: Notification) -> Bool {
        if lhs.notificationType != rhs.notificationType {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(notificationType)
        hasher.combine(message)
    }
}


public struct FfiConverterTypeNotification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Notification {
        return
            try Notification(
                notificationType: FfiConverterTypeNotificationType.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Notification, into buf: inout [UInt8]) {
        FfiConverterTypeNotificationType.write(value.notificationType, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


public func FfiConverterTypeNotification_lift(_ buf: RustBuffer) throws -> Notification {
    return try FfiConverterTypeNotification.lift(buf)
}

public func FfiConverterTypeNotification_lower(_ value: Notification) -> RustBuffer {
    return FfiConverterTypeNotification.lower(value)
}


public struct SearchResultDetail {
    public var mediumTitle: String?
    public var mediumAuthor: String?
    public var fullTitle: String?
    public var smallImageUrl: String?
    public var signature: String?
    public var dataEntries: [DataEntry]
    public var hint: String?
    public var availability: ItemAvailability

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mediumTitle: String?, mediumAuthor: String?, fullTitle: String?, smallImageUrl: String?, signature: String?, dataEntries: [DataEntry], hint: String?, availability: ItemAvailability) {
        self.mediumTitle = mediumTitle
        self.mediumAuthor = mediumAuthor
        self.fullTitle = fullTitle
        self.smallImageUrl = smallImageUrl
        self.signature = signature
        self.dataEntries = dataEntries
        self.hint = hint
        self.availability = availability
    }
}



extension SearchResultDetail: Equatable, Hashable {
    public static func ==(lhs: SearchResultDetail, rhs: SearchResultDetail) -> Bool {
        if lhs.mediumTitle != rhs.mediumTitle {
            return false
        }
        if lhs.mediumAuthor != rhs.mediumAuthor {
            return false
        }
        if lhs.fullTitle != rhs.fullTitle {
            return false
        }
        if lhs.smallImageUrl != rhs.smallImageUrl {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.dataEntries != rhs.dataEntries {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        if lhs.availability != rhs.availability {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mediumTitle)
        hasher.combine(mediumAuthor)
        hasher.combine(fullTitle)
        hasher.combine(smallImageUrl)
        hasher.combine(signature)
        hasher.combine(dataEntries)
        hasher.combine(hint)
        hasher.combine(availability)
    }
}


public struct FfiConverterTypeSearchResultDetail: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchResultDetail {
        return
            try SearchResultDetail(
                mediumTitle: FfiConverterOptionString.read(from: &buf), 
                mediumAuthor: FfiConverterOptionString.read(from: &buf), 
                fullTitle: FfiConverterOptionString.read(from: &buf), 
                smallImageUrl: FfiConverterOptionString.read(from: &buf), 
                signature: FfiConverterOptionString.read(from: &buf), 
                dataEntries: FfiConverterSequenceTypeDataEntry.read(from: &buf), 
                hint: FfiConverterOptionString.read(from: &buf), 
                availability: FfiConverterTypeItemAvailability.read(from: &buf)
        )
    }

    public static func write(_ value: SearchResultDetail, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.mediumTitle, into: &buf)
        FfiConverterOptionString.write(value.mediumAuthor, into: &buf)
        FfiConverterOptionString.write(value.fullTitle, into: &buf)
        FfiConverterOptionString.write(value.smallImageUrl, into: &buf)
        FfiConverterOptionString.write(value.signature, into: &buf)
        FfiConverterSequenceTypeDataEntry.write(value.dataEntries, into: &buf)
        FfiConverterOptionString.write(value.hint, into: &buf)
        FfiConverterTypeItemAvailability.write(value.availability, into: &buf)
    }
}


public func FfiConverterTypeSearchResultDetail_lift(_ buf: RustBuffer) throws -> SearchResultDetail {
    return try FfiConverterTypeSearchResultDetail.lift(buf)
}

public func FfiConverterTypeSearchResultDetail_lower(_ value: SearchResultDetail) -> RustBuffer {
    return FfiConverterTypeSearchResultDetail.lower(value)
}


public struct SearchResultList {
    public var text: String
    public var nextPageUrl: String?
    public var resultCount: UInt32
    public var items: [SearchResultListItem]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(text: String, nextPageUrl: String?, resultCount: UInt32, items: [SearchResultListItem]) {
        self.text = text
        self.nextPageUrl = nextPageUrl
        self.resultCount = resultCount
        self.items = items
    }
}



extension SearchResultList: Equatable, Hashable {
    public static func ==(lhs: SearchResultList, rhs: SearchResultList) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        if lhs.nextPageUrl != rhs.nextPageUrl {
            return false
        }
        if lhs.resultCount != rhs.resultCount {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
        hasher.combine(nextPageUrl)
        hasher.combine(resultCount)
        hasher.combine(items)
    }
}


public struct FfiConverterTypeSearchResultList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchResultList {
        return
            try SearchResultList(
                text: FfiConverterString.read(from: &buf), 
                nextPageUrl: FfiConverterOptionString.read(from: &buf), 
                resultCount: FfiConverterUInt32.read(from: &buf), 
                items: FfiConverterSequenceTypeSearchResultListItem.read(from: &buf)
        )
    }

    public static func write(_ value: SearchResultList, into buf: inout [UInt8]) {
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterOptionString.write(value.nextPageUrl, into: &buf)
        FfiConverterUInt32.write(value.resultCount, into: &buf)
        FfiConverterSequenceTypeSearchResultListItem.write(value.items, into: &buf)
    }
}


public func FfiConverterTypeSearchResultList_lift(_ buf: RustBuffer) throws -> SearchResultList {
    return try FfiConverterTypeSearchResultList.lift(buf)
}

public func FfiConverterTypeSearchResultList_lower(_ value: SearchResultList) -> RustBuffer {
    return FfiConverterTypeSearchResultList.lower(value)
}


public struct SearchResultListItem {
    public var identifier: String
    public var title: String?
    public var subtitle: String?
    public var itemNumber: String?
    public var detailUrl: String?
    public var coverImageUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: String, title: String?, subtitle: String?, itemNumber: String?, detailUrl: String?, coverImageUrl: String?) {
        self.identifier = identifier
        self.title = title
        self.subtitle = subtitle
        self.itemNumber = itemNumber
        self.detailUrl = detailUrl
        self.coverImageUrl = coverImageUrl
    }
}



extension SearchResultListItem: Equatable, Hashable {
    public static func ==(lhs: SearchResultListItem, rhs: SearchResultListItem) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.subtitle != rhs.subtitle {
            return false
        }
        if lhs.itemNumber != rhs.itemNumber {
            return false
        }
        if lhs.detailUrl != rhs.detailUrl {
            return false
        }
        if lhs.coverImageUrl != rhs.coverImageUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(title)
        hasher.combine(subtitle)
        hasher.combine(itemNumber)
        hasher.combine(detailUrl)
        hasher.combine(coverImageUrl)
    }
}


public struct FfiConverterTypeSearchResultListItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchResultListItem {
        return
            try SearchResultListItem(
                identifier: FfiConverterString.read(from: &buf), 
                title: FfiConverterOptionString.read(from: &buf), 
                subtitle: FfiConverterOptionString.read(from: &buf), 
                itemNumber: FfiConverterOptionString.read(from: &buf), 
                detailUrl: FfiConverterOptionString.read(from: &buf), 
                coverImageUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SearchResultListItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.subtitle, into: &buf)
        FfiConverterOptionString.write(value.itemNumber, into: &buf)
        FfiConverterOptionString.write(value.detailUrl, into: &buf)
        FfiConverterOptionString.write(value.coverImageUrl, into: &buf)
    }
}


public func FfiConverterTypeSearchResultListItem_lift(_ buf: RustBuffer) throws -> SearchResultListItem {
    return try FfiConverterTypeSearchResultListItem.lift(buf)
}

public func FfiConverterTypeSearchResultListItem_lower(_ value: SearchResultListItem) -> RustBuffer {
    return FfiConverterTypeSearchResultListItem.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Api {
    
    case hamburgPublic
    case opc4v213vzg6
}


public struct FfiConverterTypeAPI: FfiConverterRustBuffer {
    typealias SwiftType = Api

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Api {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hamburgPublic
        
        case 2: return .opc4v213vzg6
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Api, into buf: inout [UInt8]) {
        switch value {
        
        
        case .hamburgPublic:
            writeInt(&buf, Int32(1))
        
        
        case .opc4v213vzg6:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeAPI_lift(_ buf: RustBuffer) throws -> Api {
    return try FfiConverterTypeAPI.lift(buf)
}

public func FfiConverterTypeAPI_lower(_ value: Api) -> RustBuffer {
    return FfiConverterTypeAPI.lower(value)
}



extension Api: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Availability {
    
    case available(Location
    )
    case notAvailable(Location
    )
    case unknown(Location
    )
}


public struct FfiConverterTypeAvailability: FfiConverterRustBuffer {
    typealias SwiftType = Availability

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Availability {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .available(try FfiConverterTypeLocation.read(from: &buf)
        )
        
        case 2: return .notAvailable(try FfiConverterTypeLocation.read(from: &buf)
        )
        
        case 3: return .unknown(try FfiConverterTypeLocation.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Availability, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .available(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeLocation.write(v1, into: &buf)
            
        
        case let .notAvailable(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLocation.write(v1, into: &buf)
            
        
        case let .unknown(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeLocation.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAvailability_lift(_ buf: RustBuffer) throws -> Availability {
    return try FfiConverterTypeAvailability.lift(buf)
}

public func FfiConverterTypeAvailability_lower(_ value: Availability) -> RustBuffer {
    return FfiConverterTypeAvailability.lower(value)
}



extension Availability: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AvailabilityStatus {
    
    case allAvailable
    case noneAvailable
    case someAvailable
}


public struct FfiConverterTypeAvailabilityStatus: FfiConverterRustBuffer {
    typealias SwiftType = AvailabilityStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AvailabilityStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allAvailable
        
        case 2: return .noneAvailable
        
        case 3: return .someAvailable
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AvailabilityStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allAvailable:
            writeInt(&buf, Int32(1))
        
        
        case .noneAvailable:
            writeInt(&buf, Int32(2))
        
        
        case .someAvailable:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeAvailabilityStatus_lift(_ buf: RustBuffer) throws -> AvailabilityStatus {
    return try FfiConverterTypeAvailabilityStatus.lift(buf)
}

public func FfiConverterTypeAvailabilityStatus_lower(_ value: AvailabilityStatus) -> RustBuffer {
    return FfiConverterTypeAvailabilityStatus.lower(value)
}



extension AvailabilityStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NotificationType {
    
    case info
    case warning
    case error
}


public struct FfiConverterTypeNotificationType: FfiConverterRustBuffer {
    typealias SwiftType = NotificationType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .info
        
        case 2: return .warning
        
        case 3: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .info:
            writeInt(&buf, Int32(1))
        
        
        case .warning:
            writeInt(&buf, Int32(2))
        
        
        case .error:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeNotificationType_lift(_ buf: RustBuffer) throws -> NotificationType {
    return try FfiConverterTypeNotificationType.lift(buf)
}

public func FfiConverterTypeNotificationType_lower(_ value: NotificationType) -> RustBuffer {
    return FfiConverterTypeNotificationType.lower(value)
}



extension NotificationType: Equatable, Hashable {}




public enum PaperError {

    
    
    case NotImplementedError
    case GeneralError
    case LibraryNotSupportedError
    case SearchFailed
    case FailedToRenew
    case RenewalTokenParserFailedToParseToken
    case MissingRenewalToken
    case FailedToParseRenewedLoan
    case FailedToParseLoans
    case FailedToRenewLoanBecauseItIsNotLoaned
    case LoginCurrentlyNotPossible
    case IncorrectCredentials
    case CredentialsBadInput
    case FailedToReadSessionTokenResponseBody
    case FailedToGetSessionTokenResponse
    case FailedToGetRequestToken
    case FailedToGetResourceResponseContent
    case ErrorGettingResourceResponse
    case FailedToCreateAccountInfoFromXml
    case IsInvalidBrwrNum
    case ParseErrorAccountInfoName
    case ParseErrorAccountInfoAccountId
    case ParseErrorAccountInfoAddress
    case ParseErrorAccountInfoEmail
    case ParseErrorAccountInfoPhone
    case ParseErrorAccountInfoServiceStatus
    case ParseErrorSearchResultDetail
    case ParseErrorAccountInfoServiceChargeInfo
    case ParseErrorAccountInfoServiceChargeAmount
    case ParseErrorAccountInfoBalance
    case ErrorParsingUrl
    case ReqwestError(String
    )
    case IoError(String
    )
    case ParserError(String
    )
    case ErrorWithMessage(String
    )
}


public struct FfiConverterTypePaperError: FfiConverterRustBuffer {
    typealias SwiftType = PaperError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaperError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NotImplementedError
        case 2: return .GeneralError
        case 3: return .LibraryNotSupportedError
        case 4: return .SearchFailed
        case 5: return .FailedToRenew
        case 6: return .RenewalTokenParserFailedToParseToken
        case 7: return .MissingRenewalToken
        case 8: return .FailedToParseRenewedLoan
        case 9: return .FailedToParseLoans
        case 10: return .FailedToRenewLoanBecauseItIsNotLoaned
        case 11: return .LoginCurrentlyNotPossible
        case 12: return .IncorrectCredentials
        case 13: return .CredentialsBadInput
        case 14: return .FailedToReadSessionTokenResponseBody
        case 15: return .FailedToGetSessionTokenResponse
        case 16: return .FailedToGetRequestToken
        case 17: return .FailedToGetResourceResponseContent
        case 18: return .ErrorGettingResourceResponse
        case 19: return .FailedToCreateAccountInfoFromXml
        case 20: return .IsInvalidBrwrNum
        case 21: return .ParseErrorAccountInfoName
        case 22: return .ParseErrorAccountInfoAccountId
        case 23: return .ParseErrorAccountInfoAddress
        case 24: return .ParseErrorAccountInfoEmail
        case 25: return .ParseErrorAccountInfoPhone
        case 26: return .ParseErrorAccountInfoServiceStatus
        case 27: return .ParseErrorSearchResultDetail
        case 28: return .ParseErrorAccountInfoServiceChargeInfo
        case 29: return .ParseErrorAccountInfoServiceChargeAmount
        case 30: return .ParseErrorAccountInfoBalance
        case 31: return .ErrorParsingUrl
        case 32: return .ReqwestError(
            try FfiConverterString.read(from: &buf)
            )
        case 33: return .IoError(
            try FfiConverterString.read(from: &buf)
            )
        case 34: return .ParserError(
            try FfiConverterString.read(from: &buf)
            )
        case 35: return .ErrorWithMessage(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaperError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .NotImplementedError:
            writeInt(&buf, Int32(1))
        
        
        case .GeneralError:
            writeInt(&buf, Int32(2))
        
        
        case .LibraryNotSupportedError:
            writeInt(&buf, Int32(3))
        
        
        case .SearchFailed:
            writeInt(&buf, Int32(4))
        
        
        case .FailedToRenew:
            writeInt(&buf, Int32(5))
        
        
        case .RenewalTokenParserFailedToParseToken:
            writeInt(&buf, Int32(6))
        
        
        case .MissingRenewalToken:
            writeInt(&buf, Int32(7))
        
        
        case .FailedToParseRenewedLoan:
            writeInt(&buf, Int32(8))
        
        
        case .FailedToParseLoans:
            writeInt(&buf, Int32(9))
        
        
        case .FailedToRenewLoanBecauseItIsNotLoaned:
            writeInt(&buf, Int32(10))
        
        
        case .LoginCurrentlyNotPossible:
            writeInt(&buf, Int32(11))
        
        
        case .IncorrectCredentials:
            writeInt(&buf, Int32(12))
        
        
        case .CredentialsBadInput:
            writeInt(&buf, Int32(13))
        
        
        case .FailedToReadSessionTokenResponseBody:
            writeInt(&buf, Int32(14))
        
        
        case .FailedToGetSessionTokenResponse:
            writeInt(&buf, Int32(15))
        
        
        case .FailedToGetRequestToken:
            writeInt(&buf, Int32(16))
        
        
        case .FailedToGetResourceResponseContent:
            writeInt(&buf, Int32(17))
        
        
        case .ErrorGettingResourceResponse:
            writeInt(&buf, Int32(18))
        
        
        case .FailedToCreateAccountInfoFromXml:
            writeInt(&buf, Int32(19))
        
        
        case .IsInvalidBrwrNum:
            writeInt(&buf, Int32(20))
        
        
        case .ParseErrorAccountInfoName:
            writeInt(&buf, Int32(21))
        
        
        case .ParseErrorAccountInfoAccountId:
            writeInt(&buf, Int32(22))
        
        
        case .ParseErrorAccountInfoAddress:
            writeInt(&buf, Int32(23))
        
        
        case .ParseErrorAccountInfoEmail:
            writeInt(&buf, Int32(24))
        
        
        case .ParseErrorAccountInfoPhone:
            writeInt(&buf, Int32(25))
        
        
        case .ParseErrorAccountInfoServiceStatus:
            writeInt(&buf, Int32(26))
        
        
        case .ParseErrorSearchResultDetail:
            writeInt(&buf, Int32(27))
        
        
        case .ParseErrorAccountInfoServiceChargeInfo:
            writeInt(&buf, Int32(28))
        
        
        case .ParseErrorAccountInfoServiceChargeAmount:
            writeInt(&buf, Int32(29))
        
        
        case .ParseErrorAccountInfoBalance:
            writeInt(&buf, Int32(30))
        
        
        case .ErrorParsingUrl:
            writeInt(&buf, Int32(31))
        
        
        case let .ReqwestError(v1):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .IoError(v1):
            writeInt(&buf, Int32(33))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ParserError(v1):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ErrorWithMessage(v1):
            writeInt(&buf, Int32(35))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension PaperError: Equatable, Hashable {}

extension PaperError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ValidationStatus {
    
    case valid
    case invalid
    case error(String
    )
}


public struct FfiConverterTypeValidationStatus: FfiConverterRustBuffer {
    typealias SwiftType = ValidationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .valid
        
        case 2: return .invalid
        
        case 3: return .error(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ValidationStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .valid:
            writeInt(&buf, Int32(1))
        
        
        case .invalid:
            writeInt(&buf, Int32(2))
        
        
        case let .error(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeValidationStatus_lift(_ buf: RustBuffer) throws -> ValidationStatus {
    return try FfiConverterTypeValidationStatus.lift(buf)
}

public func FfiConverterTypeValidationStatus_lower(_ value: ValidationStatus) -> RustBuffer {
    return FfiConverterTypeValidationStatus.lower(value)
}



extension ValidationStatus: Equatable, Hashable {}



fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBalance: FfiConverterRustBuffer {
    typealias SwiftType = Balance?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBalance.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBalance.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceTypeCharge: FfiConverterRustBuffer {
    typealias SwiftType = [Charge]

    public static func write(_ value: [Charge], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCharge.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Charge] {
        let len: Int32 = try readInt(&buf)
        var seq = [Charge]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCharge.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDataEntry: FfiConverterRustBuffer {
    typealias SwiftType = [DataEntry]

    public static func write(_ value: [DataEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDataEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DataEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [DataEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDataEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLoan: FfiConverterRustBuffer {
    typealias SwiftType = [Loan]

    public static func write(_ value: [Loan], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLoan.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Loan] {
        let len: Int32 = try readInt(&buf)
        var seq = [Loan]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLoan.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNotification: FfiConverterRustBuffer {
    typealias SwiftType = [Notification]

    public static func write(_ value: [Notification], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNotification.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Notification] {
        let len: Int32 = try readInt(&buf)
        var seq = [Notification]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNotification.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSearchResultListItem: FfiConverterRustBuffer {
    typealias SwiftType = [SearchResultListItem]

    public static func write(_ value: [SearchResultListItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSearchResultListItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SearchResultListItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [SearchResultListItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSearchResultListItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAvailability: FfiConverterRustBuffer {
    typealias SwiftType = [Availability]

    public static func write(_ value: [Availability], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAvailability.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Availability] {
        let len: Int32 = try readInt(&buf)
        var seq = [Availability]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAvailability.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_paper_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_paper_checksum_method_authenticator_verify_credentials() != 9971) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_method_libraryscraper_fetch_account() != 35321) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_method_renewalservice_opc4v2_13vzg6_renew() != 8773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_method_renewalservice_public_hamburg_renew() != 62294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_method_renewalservice_renew() != 14270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_method_searchdetailscraper_details_for_url() != 40000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_method_searchdetailscraper_status() != 28294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_method_searchscraper_search() != 5456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_constructor_authenticator_new() != 42481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_constructor_libraryscraper_new() != 45983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_constructor_renewalservice_new() != 32832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_constructor_searchdetailscraper_new() != 34827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paper_checksum_constructor_searchscraper_new() != 63451) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all